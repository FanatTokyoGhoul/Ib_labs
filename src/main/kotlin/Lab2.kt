fun lab2() {
    val nf = NetworkFeystel()
    nf.lab2()
}

//public static void Main(string[] args)
//{
//    // Исходное сообщение
//    Console.WriteLine("{0:X}", msg);
//
//    // Зашифрованное сообщение
//    UInt64 c_msg = shifr(msg);
//    Console.WriteLine("{0:X}", c_msg);
//
//    // Расшифрованное сообщение
//    UInt64 msg_ = rasshifr(c_msg);
//    Console.WriteLine("{0:X}", msg_);
//
//
//
//    // Отображаем на консоли исходный ключ K (и IV) для зашифровки и исходное сообщение text (все это объявлено в первых строках)
//    Console.WriteLine("Init Key {0:X}", K); 	// большой ключ K (64 бит) из битов которого создаются маленькие ключи K_i (по 32 бита)
//
//    Console.WriteLine("Init V {0:X}", IV); 	 	// дополнительный ключ (вектор) для шифровки первого блока сообщения врежимах CBC и OFB (64 бит)
//
//    // Вывод блоков сообщения до шифрования
//    Console.WriteLine("Text (message blocks)");
//    for (int b = 0; b < B; b++)
//    Console.Write("{0:X} ", msg[b]);	// выводим очередной блок сообщения
//
//    // 1. Шифрование
//
//    // 1.1. Шифрование в режиме ECB (электронная кодовая книга)
//    UInt64[] msg_ecb = new UInt64[B];
//    Console.WriteLine("\nShifr ECB:");
//
//    // Шифрование последовательно каждого блока без дополнительных преобразований
//    for (int b = 0; b < B; b++)
//    {
//        msg_ecb[b] = shifr(msg[b]);		// шифруем блок
//        Console.Write("{0:X} ", msg_ecb[b]);	// выводим очередной блок сообщения	// выводим зашифрованный блок на консоль
//        // В зашифрованном тексте 1й и 2й блоки одинаковы (3й с 4м тоже) как и в исходном сообщении - это недостаток режима ECB
//    }
//
//    // 1.2. Шифрование в режиме CBC (режим сцепления блоков шифротекста)
//    UInt64[] msg_cbc = new UInt64[B];
//    Console.WriteLine("\nShifr CBC:");
//    // Первый блок сообщения xor'ится с IV перед шифрованием:
//    UInt64 blok = msg[0] ^ IV;
//    msg_cbc[0] = shifr(blok); // шифруем блок
//    Console.Write("{0:X} ", msg_cbc[0]);	// выводим зашифрованный первый блок на консоль
//
//    // Каждый последующий блок перед шифрованием xor'ится с предыдущим зашифрованным блоком:
//    for (int b = 1; b < B; b++)
//    {
//        blok = msg[b] ^ msg_cbc[b - 1]; // xor с предыдущим зашифрованным
//        msg_cbc[b] = shifr(blok); // шифруем блок
//        Console.Write("{0:X} ", msg_cbc[b]);	// выводим зашифрованный блок на консоль
//        // В зашифрованном тексте все блоки будут разными, не смотря на то что в исходном сообщении они повторялись
//    }
//
//    // 1.3. Шифрование в режиме OFB (режим обратной связи по выходу)
//    UInt64[] msg_ofb = new UInt64[B];
//    Console.WriteLine("\nShifr OFB:");
//    blok = IV; // дополнительный ключ для зашифровки блоков текста
//
//    for (int b = 0; b < B; b++)
//    {
//        blok = shifr(blok);	// на каждом шаге шифруется этот дополнительный ключ
//        msg_ofb[b] = blok ^ msg[b]; // и xor'ится с очередным блоком сообщения - получается зашифрованный блок сообщения
//        Console.Write("{0:X} ", msg_ofb[b]);	// выводим зашифрованный блок на консоль
//        // В зашифрованном тексте все блоки будут разными, не смотря на то что в исходном сообщении они повторялись
//    }
//
//    // 2. Расшифрование
//    // 2.1. Расшифровка в режиме ECB (электронная кодовая книга)
//    UInt64 msg_b; 	// блок расшифрованного текста
//    Console.WriteLine("\nText ECB:");
//    // Расшифровка последовательно каждого блока без дополнительных преобразований
//    for (int b = 0; b < B; b++)
//    {
//        msg_b = rasshifr(msg_ecb[b]); 	// расшифровка блока
//        Console.Write("{0:X} ", msg_b); 	// выводим расшифрованный блок на консоль
//    }
//
//    // 2.2. Расшифровка в режиме CBC (режим сцепления блоков шифротекста)
//    Console.WriteLine("\nText CBC:");
//    // Первый блок сообщения xor'ится с IV после расшифровки:
//    msg_b = rasshifr(msg_cbc[0]); 	// расшифровка блока
//    msg_b ^= IV; // xor'им с IV после расшифровки
//    Console.Write("{0:X} ", msg_b);	// выводим расшифрованный первый блок на консоль
//    // Каждый последующий блок после расшифровки xor'ится с предыдущим зашифрованным блоком:
//    for (int b = 1; b < B; b++)
//    {
//        msg_b = rasshifr(msg_cbc[b]);	// расшифровка блока
//        msg_b ^= msg_cbc[b - 1]; 		// xor с предыдущим зашифрованным
//        Console.Write("{0:X} ", msg_b);	// выводим расшифрованный блок на консоль
//    }
//
//    // 2.3. Расшифровка в режиме OFB (режим обратной связи по выходу)
//    Console.WriteLine("\nText OFB:");
//    blok = IV; // дополнительный ключ для расшифровки блоков текста
//    for (int b = 0; b < B; b++)
//    {
//        blok = shifr(blok);	// на каждом шаге шифруется этот дополнительный ключ (точно так же как при шифровании)
//        msg_b = blok ^ msg_ofb[b];	// расшифрованный блок сообщения получается в результате операции xor зашифрованного блока сообщения и этого ключа
//        Console.Write("{0:X} ", msg_b);	// выводим расшифрованный блок на консоль
//    }
//}
//}